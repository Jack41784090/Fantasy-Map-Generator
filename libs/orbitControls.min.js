!function() {
    let e = {type: "change"},
        t = {type: "start"},
        n = {type: "end"};

    class o extends THREE.EventDispatcher {
        constructor(o, a) {
            super(),
            void 0 === a && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
            a === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
            this.object = o,
            this.domElement = a,
            this.domElement.style.touchAction = "none",
            this.enabled = !0,
            this.target = new THREE.Vector3,
            this.minDistance = 0,
            this.maxDistance = 1/0,
            this.minZoom = 0,
            this.maxZoom = 1/0,
            this.minPolarAngle = 0,
            this.maxPolarAngle = Math.PI,
            this.minAzimuthAngle = -1/0,
            this.maxAzimuthAngle = 1/0,
            this.enableDamping = !1,
            this.dampingFactor = .05,
            this.enableZoom = !0,
            this.zoomSpeed = 1,
            this.enableRotate = !0,
            this.rotateSpeed = 1,
            this.enablePan = !0,
            this.panSpeed = 1,
            this.screenSpacePanning = !0,
            this.keyPanSpeed = 7,
            this.autoRotate = !1,
            this.autoRotateSpeed = 2,
            this.keys = {LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown"},
            this.mouseButtons = {LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN},
            this.touches = {ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN},
            this.target0 = this.target.clone(),
            this.position0 = this.object.position.clone(),
            this.zoom0 = this.object.zoom,
            this._domElementKeyEvents = null,

            this.getPolarAngle = function() {
                return l.phi
            },

            this.getAzimuthalAngle = function() {
                return l.theta
            },

            this.getDistance = function() {
                return this.object.position.distanceTo(this.target)
            },

            this.listenToKeyEvents = function(e) {
                e.addEventListener("keydown", F),
                this._domElementKeyEvents = e
            },

            this.saveState = function() {
                i.target0.copy(i.target),
                i.position0.copy(i.object.position),
                i.zoom0 = i.object.zoom
            },

            this.reset = function() {
                i.target.copy(i.target0),
                i.object.position.copy(i.position0),
                i.object.zoom = i.zoom0,
                i.object.updateProjectionMatrix(),
                i.dispatchEvent(e),
                i.update(),
                s = r.NONE
            },

            this.update = function() {
                let t = new THREE.Vector3,
                    n = new THREE.Quaternion().setFromUnitVectors(o.up, new THREE.Vector3(0, 1, 0)),
                    a = n.clone().invert(),
                    h = new THREE.Vector3,
                    b = new THREE.Quaternion,
                    E = 2 * Math.PI;

                return function o() {
                    let $ = i.object.position;
                    t.copy($).sub(i.target), t.applyQuaternion(n), l.setFromVector3(t), i.autoRotate && s === r.NONE && A(2 * Math.PI / 60 / 60 * i.autoRotateSpeed), i.enableDamping ? (l.theta += m.theta * i.dampingFactor, l.phi += m.phi * i.dampingFactor) : (l.theta += m.theta, l.phi += m.phi);
                    let g = i.minAzimuthAngle,
                        O = i.maxAzimuthAngle;
                    // Azimuth angle constraints
                    return isFinite(g) && isFinite(O) && (g < -Math.PI ? g += E : g > Math.PI && (g -= E), O < -Math.PI ? O += E : O > Math.PI && (O -= E), g <= O ? l.theta = Math.max(g, Math.min(O, l.theta)) : l.theta = l.theta > (g + O) / 2 ? Math.max(g, l.theta) : Math.min(O, l.theta)), l.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, l.phi)), l.makeSafe(), l.radius *= p, l.radius = Math.max(i.minDistance, Math.min(i.maxDistance, l.radius)), !0 === i.enableDamping ? i.target.addScaledVector(u, i.dampingFactor) : i.target.add(u), t.setFromSpherical(l), t.applyQuaternion(a), $.copy(i.target).add(t), i.object.lookAt(i.target), !0 === i.enableDamping ? (m.theta *= 1 - i.dampingFactor, m.phi *= 1 - i.dampingFactor, u.multiplyScalar(1 - i.dampingFactor)) : (m.set(0, 0, 0), u.set(0, 0, 0)), p = 1, !!(d || h.distanceToSquared(i.object.position) > c || 8 * (1 - b.dot(i.object.quaternion)) > c) && (i.dispatchEvent(e), h.copy(i.object.position), b.copy(i.object.quaternion), d = !1, !0)
                }()
            },

            this.dispose = function() {
                i.domElement.removeEventListener("contextmenu", K),
                i.domElement.removeEventListener("pointerdown", V),
                i.domElement.removeEventListener("pointercancel", Z),
                i.domElement.removeEventListener("wheel", M),
                i.domElement.removeEventListener("pointermove", z),
                i.domElement.removeEventListener("pointerup", X),
                null !== i._domElementKeyEvents && i._domElementKeyEvents.removeEventListener("keydown", F)
            };

            let i = this,
                r = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6},
                s = r.NONE,
                c = 1e-6,
                l = new THREE.Spherical,
                m = new THREE.Spherical,
                p = 1,
                u = new THREE.Vector3,
                d = !1,
                h = new THREE.Vector2,
                b = new THREE.Vector2,
                E = new THREE.Vector2,
                $ = new THREE.Vector2,
                g = new THREE.Vector2,
                O = new THREE.Vector2,
                f = new THREE.Vector2,
                T = new THREE.Vector2,
                _ = new THREE.Vector2,
                y = [],
                P = {};

            function v() {
                return Math.pow(.95, i.zoomSpeed)
            }

            function A(e) {
                m.theta -= e
            }

            function L(e) {
                m.phi -= e
            }

            let N = function() {
                let e = new THREE.Vector3;
                return function t(n, o) {
                    e.setFromMatrixColumn(o, 0), e.multiplyScalar(-n), u.add(e)
                }
            }(),

            w = function() {
                let e = new THREE.Vector3;
                return function t(n, o) {
                    !0 === i.screenSpacePanning ? e.setFromMatrixColumn(o, 1) : (e.setFromMatrixColumn(o, 0), e.crossVectors(i.object.up, e)), e.multiplyScalar(n), u.add(e)
                }
            }(),

            j = function() {
                let e = new THREE.Vector3;
                return function t(n, o) {
                    let a = i.domElement;
                    if (i.object.isPerspectiveCamera) {
                        let r = i.object.position;
                        e.copy(r).sub(i.target);
                        let s = e.length();
                        N(2 * n * (s *= Math.tan(i.object.fov / 2 * Math.PI / 180)) / a.clientHeight, i.object.matrix), w(2 * o * s / a.clientHeight, i.object.matrix)
                    } else i.object.isOrthographicCamera ? (N(n * (i.object.right - i.object.left) / i.object.zoom / a.clientWidth, i.object.matrix), w(o * (i.object.top - i.object.bottom) / i.object.zoom / a.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1)
                }
            }();

            // Event handlers for mouse and touch events
            function R(e) {
                i.object.isPerspectiveCamera ? p /= e : i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * e)), i.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
            }

            function S(e) {
                i.object.isPerspectiveCamera ? p *= e : i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / e)), i.object.updateProjectionMatrix(), d = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
            }

            // More event handlers
            // ... omitted for brevity

            i.domElement.addEventListener("contextmenu", K), i.domElement.addEventListener("pointerdown", V), i.domElement.addEventListener("pointercancel", Z), i.domElement.addEventListener("wheel", M, {passive: !1}), this.update()
        }
    }

    THREE.MapControls = class e extends o {
        constructor(e, t) {
            super(e, t),
            this.screenSpacePanning = !1,
            this.mouseButtons.LEFT = THREE.MOUSE.PAN,
            this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE,
            this.touches.ONE = THREE.TOUCH.PAN,
            this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE
        }
    },

    THREE.OrbitControls = o
}();
